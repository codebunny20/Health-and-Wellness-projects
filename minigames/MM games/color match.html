<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>Color Gradient Match</title>
	<style>
		:root { --card-size: 110px; --gap: 12px; --radius: 12px; --shadow: 0 6px 18px rgba(0,0,0,.12); }
		html, body { height: 100%; }
		body {
			margin: 0;
			font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
			background: conic-gradient(from 180deg at 50% 120%, #0e0f14, #0b0c10, #0e0f14);
			color: #e9eef5;
			display: grid;
			grid-template-rows: auto 1fr auto;
			gap: 14px;
		}
		header, footer {
			padding: 14px 18px;
			display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap;
			background: rgba(255,255,255,.03);
			border-bottom: 1px solid rgba(255,255,255,.06);
			backdrop-filter: blur(6px);
		}
		header h1 { font-size: 18px; margin: 0 12px 0 0; letter-spacing: .3px; }
		.controls { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
		select, button {
			background: rgba(103, 5, 107, 0.58);
			color: #74367f;
			border: 1px solid rgba(255,255,255,.12);
			border-radius: 10px;
			padding: 8px 12px;
			cursor: pointer;
			box-shadow: var(--shadow);
		}
		button.primary { background: #5c7cff; border-color: #7590ff; color: #fff; }
		button:disabled { opacity: .6; cursor: not-allowed; }
		.stats { display: flex; gap: 16px; opacity: .9; font-size: 14px; }
		main { padding: 10px 14px 20px; display: grid; place-items: start center; }
		.board {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(var(--card-size), 1fr));
			gap: var(--gap);
			width: min(100%, 920px);
		}
		.card {
			width: 100%;
			aspect-ratio: 3 / 4;
			perspective: 800px;
			border-radius: var(--radius);
			outline: none;
		}
		.card-inner {
			position: relative;
			width: 100%; height: 100%;
			transform-style: preserve-3d;
			transition: transform 360ms cubic-bezier(.2,.8,.2,1);
			border-radius: var(--radius);
			box-shadow: var(--shadow);
		}
		.card.flipped .card-inner { transform: rotateY(180deg); }
		.card.matched { pointer-events: none; }
		.face {
			position: absolute; inset: 0;
			border-radius: var(--radius);
			backface-visibility: hidden;
		}
		.face.back {
			background:
				radial-gradient(20px 20px at 20% 25%, rgba(255,255,255,.06), transparent 60%),
				radial-gradient(18px 18px at 80% 70%, rgba(255,255,255,.05), transparent 60%),
				linear-gradient(160deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
			border: 1px solid rgba(255,255,255,.12);
			display: grid; place-items: center;
		}
		.face.back::after {
			content: "";
			width: 38%; height: 38%;
			border-radius: 50%;
			background: radial-gradient(circle at 30% 30%, #9ec1ff, #5c7cff);
			filter: blur(2px) saturate(1.2);
			opacity: .85;
		}
		.face.front {
			transform: rotateY(180deg);
			border: 1px solid rgba(255,255,255,.16);
		}
		footer { font-size: 12px; color: #cfd7e7; border-top: 1px solid rgba(255,255,255,.06); }
		.tip { opacity: .8; }
		@media (max-width: 540px) {
			:root { --card-size: 90px; --gap: 10px; }
			header { gap: 10px; }
			.stats { width: 100%; justify-content: space-between; }
		}
	</style>
</head>
<body>
	<header>
		<div style="display:flex;align-items:center;gap:8px;">
			<h1>Color Gradient Match</h1>
			<span class="tip">Match pairs by hue/gradient.</span>
		</div>
		<div class="controls" role="group" aria-label="Game controls">
			<label for="difficulty">Difficulty</label>
			<select id="difficulty" aria-label="Select difficulty">
				<option value="6">Easy (6 pairs)</option>
				<option value="8" selected>Normal (8 pairs)</option>
				<option value="10">Hard (10 pairs)</option>
				<option value="12">Expert (12 pairs)</option>
			</select>
			<button id="newGame" class="primary">New Game</button>
		</div>
		<div class="stats" aria-live="polite">
			<div>Moves: <span id="moves">0</span></div>
			<div>Matches: <span id="matches">0</span>/<span id="pairs">0</span></div>
			<div>Time: <span id="time">0:00</span></div>
		</div>
	</header>

	<main>
		<div id="board" class="board" aria-label="Memory board" role="grid"></div>
	</main>

	<footer>
		Tip: Focus a card and press Space/Enter to flip. Gradients in a pair share the same hue family.
	</footer>

	<script>
		(() => {
			const board = document.getElementById('board');
			const movesEl = document.getElementById('moves');
			const matchesEl = document.getElementById('matches');
			const pairsEl = document.getElementById('pairs');
			const timeEl = document.getElementById('time');
			const diffEl = document.getElementById('difficulty');
			const newBtn = document.getElementById('newGame');

			let state = {
				pairs: 8,
				moves: 0,
				matches: 0,
				first: null,
				lock: false,
				started: false,
				startTime: 0,
				timer: null
			};

			function formatTime(ms) {
				const s = Math.floor(ms / 1000);
				const m = Math.floor(s / 60);
				const r = s % 60;
				return `${m}:${r.toString().padStart(2,'0')}`;
			}

			function startTimer() {
				if (state.timer) return;
				state.started = true;
				state.startTime = performance.now();
				state.timer = setInterval(() => {
					timeEl.textContent = formatTime(performance.now() - state.startTime);
				}, 250);
			}

			function stopTimer() {
				if (state.timer) {
					clearInterval(state.timer);
					state.timer = null;
				}
			}

			function shuffle(arr) {
				for (let i = arr.length - 1; i > 0; i--) {
					const j = Math.floor(Math.random() * (i + 1));
					[arr[i], arr[j]] = [arr[j], arr[i]];
				}
				return arr;
			}

			function clampHue(h) { h %= 360; return h < 0 ? h + 360 : h; }

			function makeGradientByHue(h) {
				const s = 85;
				const l1 = 56, l2 = 44;
				const a = clampHue(h - 12), b = clampHue(h + 12);
				return `linear-gradient(135deg, hsl(${a} ${s}% ${l1}%), hsl(${b} ${s}% ${l2}%))`;
			}

			function buildPairs(count) {
				// Evenly spaced hues for clear distinction
				const pairs = [];
				const jitter = () => (Math.random() * 10 - 5); // small randomness
				for (let i = 0; i < count; i++) {
					const hue = Math.round((i * 360 / count) + jitter());
					const id = `h${hue}`;
					pairs.push({ id, gradient: makeGradientByHue(hue) });
				}
				return pairs;
			}

			function createCard(pair) {
				const card = document.createElement('div');
				card.className = 'card';
				card.setAttribute('role', 'button');
				card.setAttribute('tabindex', '0');
				card.setAttribute('aria-pressed', 'false');
				card.dataset.pair = pair.id;

				const inner = document.createElement('div');
				inner.className = 'card-inner';
				const front = document.createElement('div');
				front.className = 'face front';
				front.style.background = pair.gradient;

				const back = document.createElement('div');
				back.className = 'face back';

				inner.appendChild(front);
				inner.appendChild(back);
				card.appendChild(inner);

				card.addEventListener('click', () => flip(card));
				card.addEventListener('keydown', (e) => {
					if (e.key === 'Enter' || e.key === ' ') {
						e.preventDefault();
						flip(card);
					}
				});

				return card;
			}

			function flip(card) {
				if (state.lock || card.classList.contains('flipped') || card.classList.contains('matched')) return;
				if (!state.started) startTimer();

				card.classList.add('flipped');
				card.setAttribute('aria-pressed', 'true');

				if (!state.first) {
					state.first = card;
					return;
				}

				state.lock = true;
				state.moves++;
				movesEl.textContent = state.moves;

				const second = card;
				const isMatch = state.first.dataset.pair === second.dataset.pair;

				if (isMatch) {
					state.matches++;
					matchesEl.textContent = state.matches;

					[state.first, second].forEach(c => {
						c.classList.add('matched');
						c.setAttribute('aria-pressed', 'true');
					});
					resetTurn();

					if (state.matches === state.pairs) {
						stopTimer();
						celebrate();
					}
				} else {
					setTimeout(() => {
						[state.first, second].forEach(c => {
							c.classList.remove('flipped');
							c.setAttribute('aria-pressed', 'false');
						});
						resetTurn();
					}, 700);
				}
			}

			function resetTurn() {
				state.first = null;
				state.lock = false;
			}

			function buildDeck(pairCount) {
				const pairs = buildPairs(pairCount);
				const deck = shuffle([...pairs, ...pairs]);
				board.innerHTML = '';
				deck.forEach(p => board.appendChild(createCard(p)));
			}

			function celebrate() {
				// Simple win pulse
				board.animate(
					[{ transform: 'scale(1)' }, { transform: 'scale(1.02)' }, { transform: 'scale(1)' }],
					{ duration: 500, easing: 'ease-in-out' }
				);
			}

			function newGame() {
				stopTimer();
				state = { pairs: parseInt(diffEl.value, 10), moves: 0, matches: 0, first: null, lock: false, started: false, startTime: 0, timer: null };
				movesEl.textContent = '0';
				matchesEl.textContent = '0';
				pairsEl.textContent = String(state.pairs);
				timeEl.textContent = '0:00';
				buildDeck(state.pairs);
			}

			newBtn.addEventListener('click', newGame);
			diffEl.addEventListener('change', newGame);

			// Initialize
			newGame();
		})();
	</script>
</body>
</html>
