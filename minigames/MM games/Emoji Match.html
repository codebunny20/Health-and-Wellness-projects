<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>Emoji Match</title>
	<style>
		:root {
			--bg: #0f0a1f;
			--panel: #111827;
			--accent: #8b5cf6;
			--text: #e5e7eb;
			--muted: #9ca3af;
			--ok: #34d399;
			--bad: #f87171;
			--card: #1f2937;
		}
		html, body {
			height: 100%;
			margin: 0;
			background: radial-gradient(1200px 800px at 10% 10%, #0b0818, var(--bg));
			color: var(--text);
			font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", sans-serif;
		}
		.app {
			max-width: 900px;
			margin: 24px auto;
			padding: 16px;
		}
		.header {
			display: flex;
			flex-wrap: wrap;
			align-items: center;
			justify-content: space-between;
			gap: 12px;
			margin-bottom: 12px;
		}
		h1 {
			font-size: 1.6rem;
			margin: 0;
			letter-spacing: 0.5px;
		}
		.controls {
			display: flex;
			align-items: center;
			gap: 8px;
			flex-wrap: wrap;
		}
		select, button {
			background: var(--panel);
			color: var(--text);
			border: 1px solid #242938;
			border-radius: 8px;
			padding: 10px 12px;
			font-size: 0.95rem;
			cursor: pointer;
		}
		button.primary {
			background: linear-gradient(180deg, #6d28d9, #5b21b6);
			border: none;
		}
		button:disabled {
			opacity: 0.6;
			cursor: not-allowed;
		}
		.stats {
			display: flex;
			gap: 16px;
			align-items: center;
			color: var(--muted);
			margin: 8px 0 16px;
			font-size: 0.95rem;
		}
		.badge {
			background: #2a1557;
			color: #eae6ff;
			border: 1px solid #5b21b6;
			border-radius: 999px;
			padding: 6px 10px;
		}
		.grid {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(72px, 1fr));
			gap: 12px;
			align-items: stretch;
		}
		@media (min-width: 640px) {
			.grid { grid-template-columns: repeat(auto-fit, minmax(88px, 1fr)); }
		}
		.tile {
			position: relative;
			width: 100%;
			aspect-ratio: 3 / 4;
			border: 1px solid #2c3447;
			border-radius: 12px;
			background: radial-gradient(120px 120px at 20% 20%, #202a3f, var(--card));
			box-shadow: 0 6px 20px rgba(0,0,0,0.25), inset 0 1px 0 rgba(255,255,255,0.03);
			transform-style: preserve-3d;
			transition: transform 260ms ease, box-shadow 260ms ease;
			display: grid;
			place-items: center;
			user-select: none;
			outline: none;
		}
		.tile:focus-visible {
			box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.35), 0 6px 20px rgba(0,0,0,0.25);
		}
		.tile.disabled { pointer-events: none; }
		.tile.flipped { transform: rotateY(180deg); }
		.face {
			position: absolute;
			inset: 0;
			display: grid;
			place-items: center;
			border-radius: 12px;
			font-size: clamp(28px, 6.2vw, 44px);
			backface-visibility: hidden;
		}
		.front {
			color: var(--muted);
			letter-spacing: 1px;
		}
		.back {
			transform: rotateY(180deg);
			font-size: clamp(28px, 7vw, 56px);
		}
		.match {
			outline: 2px solid var(--ok);
			box-shadow: 0 0 0 2px rgba(52, 211, 153, 0.3) inset;
		}
		.footer {
			text-align: center;
			color: var(--muted);
			margin-top: 18px;
			font-size: 0.9rem;
		}
	</style>
</head>
<body>
	<div class="app" id="app">
		<div class="header">
			<h1>Emoji Match</h1>
			<div class="controls">
				<label for="difficulty" class="sr-only">Difficulty</label>
				<select id="difficulty" title="Select difficulty">
					<option value="easy">Easy ‚Äî Faces</option>
					<option value="medium">Medium ‚Äî Faces + Animals</option>
					<option value="hard" selected>Hard ‚Äî Faces + Animals + Symbols</option>
				</select>
				<button id="newGame" class="primary">New game</button>
				<button id="shuffle">Shuffle</button>
			</div>
		</div>

		<div class="stats">
			<div class="badge">Moves: <span id="moves">0</span></div>
			<div class="badge">Matches: <span id="matches">0</span>/<span id="total">0</span></div>
			<div class="badge">Time: <span id="time">0:00</span></div>
		</div>

		<div id="grid" class="grid" aria-label="Memory grid" role="grid"></div>

		<div class="footer" id="message" aria-live="polite"></div>
	</div>

	<script>
		// Data: similar-meaning emoji pairs by category
		const PAIRS = {
			faces: [
				['üòä','üòÑ'],
				['üòÇ','ü§£'],
				['üòç','ü•∞'],
				['üò¢','üò≠'],
				['üò°','ü§¨'],
				['üòâ','üòú'],
				['üòÆ','üò≤'],
				['üò¥','üí§']
			],
			animals: [
				['üê∂','üêï'],
				['üê±','üêà'],
				['üêµ','üêí'],
				['üê∞','üêá'],
				['üêÆ','üêÑ'],
				['üê∑','üêñ'],
				['üê•','üê§'],
				['üêØ','üêÖ']
			],
			symbols: [
				['‚ù§Ô∏è','üíñ'],
				['‚≠ê','üåü'],
				['‚òÄÔ∏è','üåû'],
				['üåßÔ∏è','‚òî'],
				['üöó','üöò'],
				['‚úàÔ∏è','üõ´'],
				['üè†','üè°'],
				['üîí','üîê']
			]
		};

		const CONFIG = {
			easy:   { categories: ['faces'],                       pairs: 6  },
			medium: { categories: ['faces','animals'],             pairs: 8  },
			hard:   { categories: ['faces','animals','symbols'],   pairs: 12 }
		};

		// State
		const gridEl = document.getElementById('grid');
		const movesEl = document.getElementById('moves');
		const matchesEl = document.getElementById('matches');
		const totalEl = document.getElementById('total');
		const timeEl = document.getElementById('time');
		const messageEl = document.getElementById('message');
		const difficultyEl = document.getElementById('difficulty');
		const newGameBtn = document.getElementById('newGame');
		const shuffleBtn = document.getElementById('shuffle');

		let deck = [];
		let flipped = [];
		let matchedUids = new Set();
		let moves = 0, matches = 0, totalPairs = 0;
		let timer = null, startMs = 0;

		function choice(arr, n) {
			const a = [...arr];
			for (let i = a.length - 1; i > 0; i--) {
				const j = Math.floor(Math.random() * (i + 1));
				[a[i], a[j]] = [a[j], a[i]];
			}
			return a.slice(0, n);
		}
		function shuffle(arr) {
			const a = [...arr];
			for (let i = a.length - 1; i > 0; i--) {
				const j = Math.floor(Math.random() * (i + 1));
				[a[i], a[j]] = [a[j], a[i]];
			}
			return a;
		}
		function fmtTime(ms) {
			const s = Math.floor(ms / 1000);
			const m = Math.floor(s / 60);
			const ss = String(s % 60).padStart(2,'0');
			return `${m}:${ss}`;
		}
		function stopTimer() {
			if (timer) { clearInterval(timer); timer = null; }
		}
		function resetTimer() {
			stopTimer();
			timeEl.textContent = '0:00';
			startMs = 0;
		}
		function startTimer() {
			if (timer) return;
			startMs = Date.now();
			timer = setInterval(() => {
				timeEl.textContent = fmtTime(Date.now() - startMs);
			}, 250);
		}

		function buildDeck(difficulty) {
			const cfg = CONFIG[difficulty] ?? CONFIG.hard;
			// Gather candidate pairs across selected categories
			let candidates = [];
			for (const cat of cfg.categories) {
				const list = PAIRS[cat] || [];
				candidates.push(...list.map((pair, idx) => ({ pair, pairId: `${cat}-${idx}` })));
			}
			// Pick desired number of pairs, shuffle to mix categories
			const picked = choice(candidates, Math.min(cfg.pairs, candidates.length));
			totalPairs = picked.length;
			// Build a deck: two unique cards per pair, each with different emoji
			const raw = [];
			for (const { pair, pairId } of picked) {
				const [a, b] = pair;
				raw.push({ uid: `${pairId}-a`, pairId, emoji: a });
				raw.push({ uid: `${pairId}-b`, pairId, emoji: b });
			}
			return shuffle(raw);
		}

		function renderDeck() {
			gridEl.innerHTML = '';
			gridEl.style.setProperty('--count', deck.length);
			for (const card of deck) {
				const btn = document.createElement('button');
				btn.className = 'tile';
				btn.type = 'button';
				btn.setAttribute('aria-label', 'Hidden card');
				btn.setAttribute('role', 'gridcell');
				btn.dataset.pair = card.pairId;
				btn.dataset.uid = card.uid;
				btn.innerHTML = `
					<span class="face front" aria-hidden="true">‚ùì</span>
					<span class="face back" aria-hidden="true">${card.emoji}</span>
				`;
				gridEl.appendChild(btn);
			}
		}

		function setMessage(text, tone = '') {
			messageEl.textContent = text || '';
			if (tone === 'win') {
				messageEl.style.color = 'var(--ok)';
			} else if (tone === 'err') {
				messageEl.style.color = 'var(--bad)';
			} else {
				messageEl.style.color = 'var(--muted)';
			}
		}

		function resetState() {
			flipped = [];
			matchedUids = new Set();
			moves = 0; matches = 0;
			movesEl.textContent = '0';
			matchesEl.textContent = '0';
			totalEl.textContent = String(totalPairs);
			resetTimer();
			setMessage('Flip two cards to start.');
		}

		function newGame() {
			const diff = difficultyEl.value;
			deck = buildDeck(diff);
			renderDeck();
			resetState();
		}

		function reshuffleSame() {
			// Keep current difficulty but reshuffle fresh selection for variety
			newGame();
		}

		function isMatched(uid) { return matchedUids.has(uid); }

		function flipTile(el) {
			el.classList.add('flipped');
			el.setAttribute('aria-label', 'Revealed card');
		}
		function unflipTile(el) {
			el.classList.remove('flipped');
			el.setAttribute('aria-label', 'Hidden card');
		}
		function lockGrid(lock) {
			if (lock) gridEl.classList.add('locking');
			else gridEl.classList.remove('locking');
			// visually indicate lock by disabling pointer events on tiles
			for (const btn of gridEl.querySelectorAll('.tile')) {
				btn.classList.toggle('disabled', lock);
			}
		}

		gridEl.addEventListener('click', (e) => {
			const btn = e.target.closest('.tile');
			if (!btn || gridEl.classList.contains('locking')) return;

			const uid = btn.dataset.uid;
			if (btn.classList.contains('flipped')) return;
			if (isMatched(uid)) return;

			if (startMs === 0) startTimer();

			flipTile(btn);
			flipped.push(btn);

			if (flipped.length === 2) {
				lockGrid(true);
				moves += 1;
				movesEl.textContent = String(moves);

				const [a, b] = flipped;
				const isPair = a.dataset.pair === b.dataset.pair && a.dataset.uid !== b.dataset.uid;

				if (isPair) {
					// Mark matched
					matchedUids.add(a.dataset.uid);
					matchedUids.add(b.dataset.uid);
					a.classList.add('match');
					b.classList.add('match');
					matches += 1;
					matchesEl.textContent = String(matches);
					setTimeout(() => {
						flipped = [];
						lockGrid(false);
						if (matches === totalPairs) {
							stopTimer();
							setMessage(`You win! ${moves} moves in ${timeEl.textContent}.`, 'win');
						}
					}, 250);
				} else {
					// Not a match
					setTimeout(() => {
						unflipTile(a);
						unflipTile(b);
						flipped = [];
						lockGrid(false);
					}, 650);
				}
			}
		});

		// Keyboard support: Enter/Space flips the focused card
		gridEl.addEventListener('keydown', (e) => {
			if (e.key === 'Enter' || e.key === ' ') {
				const btn = e.target.closest('.tile');
				if (btn) {
					e.preventDefault();
					btn.click();
				}
			}
		});

		newGameBtn.addEventListener('click', newGame);
		shuffleBtn.addEventListener('click', reshuffleSame);
		difficultyEl.addEventListener('change', newGame);

		// Init
		newGame();
	</script>
</body>
</html>
``` 
